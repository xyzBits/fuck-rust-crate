# 共享状态

到目前为止，有了一个 key-value 的服务，主要缺陷是：状态不能在连接之间共享

## 策略
在 tokio 中共享状态有两种方法：
1. 使用 Mutex 互斥锁来保护共享状态
2. 产生一个任务来管理状态并使用消息传递对其进行操作

第一种方式来处理简单的数据，对于需要异步工作的事务，比如io 原语，应该使用第二种方式，
在本章节中，共享状态是一个 HashMap 并使用 insert get 来操作，这些操作都不是异步的，因经我们使用 Mutex。

## 添加 bytes 依赖
mini-redis 中使用 bytes 中的 Bytes 类型，而不是 Vec<u8>，bytes 的目的是为网络编程提供一个健全的字节数组结构，
它在 Vec<u8> 上添加的最大功能就是 浅克隆，在 Bytes 的实例上调用 clone() 方法，不会复制底层的数据，
相反，Bytes 实例是对一些底层数据的引用计数，Bytes 类型 大致与 Arc<Vec<u8>> 类似，但还添加了一些其他功能。

## 任务，线程与竞争
当竞争很小的时候，使用阻塞的互斥锁来保护关键的部分是一种可接受的策略，
当去竞争锁时，执行任务的线程必须 阻塞下来，等待互斥锁，这不仅会阻塞当前任务，
还将阻塞当前线程上调度的其他所有任务，

默认情况下，tokio 运行时使用多线程的调度器，任务可以被任何一个运行时管理的线程调度，
如果有大量的任务被调度去执行，并且它们都需要访问互斥锁，这个时候就存在锁竞争