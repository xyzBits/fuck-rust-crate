## 什么是异步编程

大多数计算机程序的执行都是按照程序编写的顺序来执行的，
第一行代码先执行，然后是下一行，这样一直下去，
对于同步编程，当程序遇到不能立即完成的操作时，
它将被阻塞直到该操作完成为止，
比方说，建立 TCP 连接需要对等方通过网络进行交换，
这一过程可能持续相当长的时间，期间线程是阻塞的。

对于异步编程，不能立即完成的操作会被挂起到后台，
当前线程不会被阻塞，并且能够继续运行其它的事，
一旦操作完成，任务将从中断处继续处理，我们前面的示例，
只有一个任务，因此 在挂起的时候什么也没发生，但是异步程序通常有很多这样的任务

尽管异步编程可以使得应用程序非常快，但它也常会导致程序复杂得多，一旦异步操作完成，
就需要程序跟踪恢复工作所需的所有状态，
从历史角度来看，这是一个非常乏味，且容易出错的任务。

## 编程时绿色线程 Compile-time green-threading 
Rust 使用被叫做 async/await 的 feature 实现异步编程，执行异步操作的函数用 async 关键字来标记，
在示例中，connection 被定义成下面这样

```rust
use std::net::ToSocketAddrs;

pub async fn connect<T: ToSocketAddrs>(addr: T) -> Result<Client> {
    // ...
}
```

使用 async fn 定义看起来像同步函数一样，但操作是异步的，Rust 在编译时将转换 async fn 为异步操作，
任务 async fn 中的 .await 操作都会将控制权返回给线程，在后台进行操作时，线程可能会做其他工作。 


## 使用 async await 
异步函数的调用和其他 Rust 函数一样，但是调用这些函数不会导致函数体的执行，
而是调用这些函数返回表示操作的值，类似于 零参数 的闭包，
为了实际的去运行这些操作，应该使用 .await 操作符来返回值 


## 异步 main 函数 
main 函数用来启动应用，它与大多数  Rust 其它包中的函数不同
- 它是一个 async fn 
- 它使用 #[tokio::main] 注解

我们要进入一个异步上下下文时，一个 async fn 会被使用，但是异步函数必须由一个运行时来执行，
运行时包含 异步任务调度，提供io事件，计算时器等，运行时不会自动开启，因此 需要 main 函数来启动它

## Cargo 特性 
本教程中的 tokio 依赖，启用了 full 特性
```toml
tokio = {version = "0.2", features = ["full"]}
```
tokio有很多功能， tcp udp unix timers sync utilities 多种类型的调度器，
不是所有的应用都需要所有的功能，当我们尝试去优化编译时间或者应用占用空间时，
应用程序可以去选择仅仅它需要使用的特性，
比如我们现在的 tokio 中使用了 full 的特性